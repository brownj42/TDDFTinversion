[
  {
    "objectID": "propagate.html",
    "href": "propagate.html",
    "title": "",
    "section": "",
    "text": "This is the module that is used to advance individual quantum orbitals. There is both a time-independant and time dependant propagator.\n\n\n!the subroutine used to propagate the wavefunction by dt given in sysparams%dt\nsubroutine advancewf(sysparams,sharedvals,niter,vks,yin,yout)\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(in) :: sharedvals\n    integer, intent(in)  :: niter !number of matrix-vector products for Lanczos\n    real(8), intent(in) :: Vks(:) !Potential vector\n    complex(8), intent(in) :: yin(:) !input wavefunction at time t\n    complex(8), intent(out) :: yout(:) !output wavefunction at time t+dt\n!subroutine used to advance the wavefunction yin by sysparams%dt to yout\n!The time derivative of the potential at t and t+dt are optional, if they are present, a higher order\n!method is used to advance the system in time.\nsubroutine advancewftd(sysparams,sharedvals,niter,vin,vks,vksnew,dvks,dvksnew,yin,yout)\n   use derivedtypes\n   use hamiltonian_mod\n   type(systemparameters), intent(in) :: sysparams\n   type(sharedvalues), intent(in) :: sharedvals\n   integer, intent(in)  :: niter !number of iterations used for Short iterative Lanczos\n   real(8), intent(in) :: vin(:) !time independant part of potential\n   real(8), intent(in) :: Vks(:) !time-dependant part of potential at time t\n   real(8), intent(in) :: vksnew(:) !time-dependant part of potential at time t+dt\n   real(8), intent(in), optional :: dvks(:) !time derivative of potential at time t\n   real(8), intent(in), optional :: dvksnew(:) !time derivative of potential at time t+dt\nsubroutine advanceKSsystem(dpe,dpenew,dnx,ddnx,ddnxnew,sysparams,KSvals,sharedvals,info)\n!The subroutine that implements that main method to advance the KSorbitals and calculate the \n!corresponding TDDFT potential. The five vectors required to advance from ct to ct+dt are:\n!dnx: The time derivative of the density at time t\n!dpe: The density at time t\n!dpenew: The density at time t+dt\n!ddnx: The second time-derivative of the density at time t\n!ddnxnew: The second time-derivative of the density at time t+dt\n!if after attempted time step, info=1 the orbitals have advanced and vks at time t+dt is stored in\n!KSvals along with the new orbitals\n!If after attempted time step, info=0 The time step failed and new dpenew and ddnxnew are requested at\n!time t+dt where dt is now halved from the previous step.\n   real(8), intent(in) :: dnx(:),dpe(:),dpenew(:),ddnx(:),ddnxnew(:)\n   type(systemparameters), intent(inout) :: sysparams\n   type(KSvalues), intent(inout) :: KSvals\n   type(sharedvalues), intent(in) :: sharedvals\n   integer, intent(out) :: info"
  },
  {
    "objectID": "derivedtypes.html",
    "href": "derivedtypes.html",
    "title": "",
    "section": "",
    "text": "This is the module that contains the definitions of the derived types and the subroutines that initialize and destroy the allocatable arrays therein.\n\n\nThere are four derived types that are used in the program.\n\nsystemparameters: This contains all the information that defines the system being studied (mandatory)\nksvalues: This contains all the information about the Kohn-Sham system (mandatory)\nsharedvalues: This contains the one-body potential, time-independant 1-body (mandatory) potential, the 2-body interaction potential. (mandatory)\nfullvalues: This contains the full n-body wavefunction and the n-body (optional) potential\n\n\n\n\n\n\nThis subroutine allocates the arrays for the kinetic energy operator and lattice grid values in the systemparameters derived type. The number of 1d grid points is the necessary input. At this time, all dimensions have the same number of grid points.\nsubroutine init_systemparameters(sysparams,number_of_1d_points)\n    type(systemparameters), intent(out) :: sysparams\n    integer, intent(in) :: number_of_1d_points\nThis subroutine initializes the arrays in the ksvalues (Kohn-Sham values) derived type.\nsubroutine init_ksvalues(sysparams,ksvals)\n    type(systemparameters), intent(in) :: sysparams\n    type(ksvalues), intent(out) :: ksvals\nThis subroutine initializes the arrays in the sharedvalues derived type.\nsubroutine init_sharedvalues(sysparams,sharedvals)\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(out) :: sharedvals\nThis subroutine initializes the non-user defined values in the systemparameters derived type\nsubroutine fill_systemparameters(sysparams)\n    use nchoosekmod\n    type(systemparameters), intent(inout) :: sysparams\nThis subroutine initializes the arrays in the fullvalues derived type\nsubroutine init_fullvalues(sysparams,fullvals)\n        type(systemparameters), intent(in) :: sysparams\n        type(fullvalues), intent(out) :: fullvals\n\n\n\n!Destroys the arrays in systemparameters derived types\nsubroutine destroy_systemparameters(sysparams)\n    type(systemparameters), INTENT(inout) :: sysparams\n!Destroys the arrays in the sharedvalues derived types\nsubroutine destroy_sharedvalues(sharedvals)\n    type(sharedvalues), intent(inout) :: sharedvals\n!Destroys the arrays in the fullvalues derived type\nsubroutine destroy_fullvalues(fullvals)\n    type(fullvalues), intent(inout) :: fullvals\n!Destroys the arrays in the ksvalues derived types\nsubroutine destroy_ksvalues(ksvals)\n    type(ksvalues), intent(inout) :: ksvals"
  },
  {
    "objectID": "initial_states.html",
    "href": "initial_states.html",
    "title": "",
    "section": "",
    "text": "This is the module that implements the initialization of the KS orbitals for the example systems given in the paper.\n\n\n!Generates the full system wavefunction for the examples in the !paper.\nsubroutine initializefullsystem(sysparams,fullvals)\n    type(systemparameters), intent(in) :: sysparams\n    type(fullvalues), intent(inout) :: fullvals\n! returns the one electron ground state in the first KS orbital\n! KSvals%phi(:,1)= the one electron ground state given the\n! sharedvals%v1(:) potential and sysparams%T(:,:) KEO\nsubroutine oneelectrongroundstate(sysparams,sharedvals,KSvals)\n    use derivedtypes\n    use hamiltonian_mod\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(in) :: sharedvals\n    type(KSvalues), intent(out) :: KSvals\n!Initializes the KSvals%phi orbitals given the parameters in\n!sysparams and sharedvals to match the full electron density dpe\n!fullvals, optional used for case when only one electron by\n!setting KSvals%phi(:,1)=fullvals%psi(:)\nsubroutine initializeKSsystem(sysparams,sharedvals,dpe,fullvals,KSvals)\n    use derivedtypes\n    use density_mod\n    type(systemparameters), intent(in) :: sysparams\n    real(8), intent(in) :: dpe(:)\n    type(sharedvalues), intent(in) :: sharedvals\n    type(KSvalues), intent(out) :: KSvals\n    type(fullvalues), intent(in), optional :: fullvals\n!calculates all eigenstates of a 1D Hamiltonian with KEO matrix T and\n!diagonal potential v of length np1\nsubroutine calcalleigenstates(np1,T,v,eigenstates)\n     integer, intent(in) :: np1\n     real(8), intent(in) :: T(:,:)\n     real(8), intent(in) :: v(:)\n     real(8), intent(out) :: eigenstates(np1,np1)"
  },
  {
    "objectID": "potential.html",
    "href": "potential.html",
    "title": "",
    "section": "",
    "text": "This is the module that contains the subroutines that generate the example potentials. It is unnecessary to call any of these functions to run the program.\n\n\n!Generates the 1body potential given different input parameters.\nsubroutine generate_1bodypot(sysparams,sharedvals)\n    use derivedtypes\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(inout) :: sharedvals\n!Generates the 2body potential for different input parameters\nsubroutine generate_2bodypot(sysparams,sharedvals)\n    use derivedtypes\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(inout) :: sharedvals\n!Generates the full n_body wavefunction, really only used for the 1D 2-electron example\nsubroutine generate_nbodypot(sysparams,sharedvals,fullvals)\n    use derivedtypes\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(in) :: sharedvals\n    type(fullvalues), intent(inout) :: fullvals\n!adds the driving potential for the 1D 2-electron example\nsubroutine add_driving_potential(sysparams,sharedvals,fullvals)\n    use derivedtypes\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(inout) :: sharedvals\n    type(fullvalues), intent(inout) :: fullvals"
  },
  {
    "objectID": "density.html",
    "href": "density.html",
    "title": "",
    "section": "",
    "text": "The module that calculates the density and its first and second time-derivative.\n\n\nsubroutine fullwf_density(sysparams,yh,density)\n    !Calculates the fullwavefunction density given systemparameters derived type and wavefunction\n    !yh with size sysparams%ntot\n    type(systemparameters), intent(in) :: sysparams\n    complex(8), intent(in) :: yh(:)\n    real(8), intent(out) :: density(sysparams%ntot1)\nsubroutine calcddnx(sysparams,sharedvals,ntot1,psi,v,ddnx) \n    !Calculates the second time derivative of the density ddnx of length sysparams%ntot1\n    !from psi of length sysparams%ntot\n    !with potential v \n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(in) :: sharedvals \n    integer, intent(in) :: ntot1\n    real(8), intent(in) :: v(:)\n    complex(8), intent(in) :: psi(:)\n    real(8), intent(out) :: ddnx(sysparams%ntot1)\nsubroutine calcdnx(sysparams,sharedvals,ntot1,psi,v,dnx)\n    !Calculates the second time derivative of the density dnx of length sysparams%ntot1\n    !from psi of length sysparams%ntot\n    !with potential v\n    type(systemparameters), intent(in) :: sysparams\n    type(sharedvalues), intent(in) :: sharedvals \n    integer, intent(in) :: ntot1\n    real(8), intent(in) :: v(:)\n    complex(8), intent(in) :: psi(:)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "This is a basic introduction to using the TDDFTinversion program that can be found at\nMore information about the various modules can be found at\n\npotential Various subroutines that generate the potentials for the various examples\ndensity Subroutines that calculate the density and its first and second time-derivative for a wavefunction\nkeomod Calculates the sinc DVR kinetic energy operator\npropagate Propagates either a wavefunction or attempts to advance the Kohn-Sham orbitals\ninitials_states Subroutines that initialize either the Kohn-Sham system or the corresponding full system for the examples in the paper.\n\n\n\nThe initialization mainly uses derived types and subroutines located in the derivedtypes module.\nThere are three different mandatory derived types that are used in the program.\n\nsystemparameters: This contains all the information that defines the system being studied\nksvalues: This contains all the information about the Kohn-Sham system\nsharedvalues: This contains the one-body potential, time-independant 1-body potential, the 2-body interaction potential.\n\nAdditionally, there is the optional\n\nfullvalues: This contains the full n-body wavefunction and the n-body potential\n\nThe program uses a direct-product of grids. To initialize the systemparameters derived types, you need to define the number of grid points in one-dimension (L) and then\n\nFortran:\n\n   use derivedtypes\n   integer, parameter :: number_of_1d_points=L\n   type(systemparameters) :: sysparams\n   call init_systemparameters(sysparams,number_of_1d_points)\n\nPython:\n\n   import TDDFTinversion as td\n   sysparams=td.derivedtypes.init_systemparameters(number_of_1d_points)\nYou now have access to the systemparameters derived type that you must fill out a few values with.\n\nFortran\n\n  sysparams%np1=L ![*integer*]\n  sysparams%nd= !number of dimensions [*integer*]\n  sysparams%npart = !number of particles [*integer*] \n  sysparams%xmin = !minimum grid point position [*integer*]\n  sysparams%xmax = !maximum grid point value [*integer*]\n  sysparams%ct = !current time [*real(8)*]\n  sysparams%dth = !goal time step size [*real(8)*]\n  sysparams%dvksmax = !maximum allowable potential derivative with respect to\n                      !time (1000 is generally a reasonable choice) [*real(8)*]\n  sysparams%pinv0minresqlp1 = !use pseudoinverse, set to 0 (only for 1D\n                              !problems); use MINRES-QLP, set to 1 (The preferred choice) [*integer*]\n  sysparams%quantization = !First Quantization, set to 1; Second quantization,\n                           !set to 2 [*integer*]\n  sysparams%energy = !KS system energy, can be anthing [*real(8)*]\n  sysparams%T = !1D Laplacian d^2/dx^2 (can use ``call buildkeo(sysparams)\" \n                !for using sinc basis) [*real(8)*, *dimension(L,L)*]\n  sysparams%xlattice = !positions of lattice points [*real(8), dimension(L)*]\n\nPython\n\n  sysparams.np1=L #(*np.int32*)\n  sysparams.nd= #number of dimensions (*np.int32*)\n  sysparams.npart = #number of particles (*np.int32*)\n  sysparams.xmin = #minimum grid point position (*np.int32*)\n  sysparams.xmax = #maximum grid point value (*np.int32*)\n  sysparams.ct = #current time (can be anything) (*np.float64*)\n  sysparams.dth = #goal time step size (*np.float64*)\n  sysparams.dvksmax = #maximum allowable potential derivative with respect to\n                      #time (1000 is generally a reasonable choice) (*np.float64*)\n  sysparams.pinv0minresqlp1 = #use pseudoinverse, set to 0 (only for 1D\n                              #problems); use MINRES-QLP, set to 1 (The preferred choice) (*np.int32*)\n  sysparams.quantization = #First Quantization, set to 1; Second quantization,\n                           #set to 2 (*np.int32*)\n  sysparams.energy = #KS system energy, can be anthing (*np.float64*)\n  sysparams.T = #1D Laplacian d^2/dx^2 (can use ``td.keomod.buildkeo(sysparams)\"\n                #for using sinc basis) (*np.float64, shape((L,L))*)\n  sysparams.xlattice = #position of lattice points [*np.float64,shape(L)*]\nA subroutine that builds the sinc DVR KEO is found at keomod\n\n\n\nThere are some parts of the sysparams derived type that need to be calculated using the above information\n\nFortran:\n\n  call fill_systemparameters(sysparams)\n\nPython:\n\n  td.derivedtypes.fill_systemparameters(sysparams)\n\n\n\n\nFortran:\n\n  type(sharedvalues):: sharedvals\n  call init_sharedvalues(sysparams,sharedvals)\n\nPython:\n\n  sharedvals=td.derivedtypes.init_sharedvalues(sysparams)\n\n\n\nThere are two portions of sharedvalues that need to be defined\n\nThe 1-body potential of length L^(number of dimensions) sharedvals%v1\nThe 1-body time-independant potential of length L^(number of dimensions) sharedvals%vin\nThe 2-body potential of length L^(number of dimensions)^2\n\nFor certain parameters, can obtain the examples in the paper using\n\nFortran:\n\n  use potential\n  call generate_1bodypot(sysparams,sharedvals)\n  call generate_2bodypot(sysparams,sharedvals)\n\nPython:\n\n  td.potential.generate_1bodypot(sysparams,sharedvals)\n  td.potential.generate_2bodypot(sysparams,sharedvals)\n\n\n\n\nFortran\n\n  type(fullvalues) :: fullvals\n  call init_fullvals(sysparams,fullvals)\n\nPython\n\n  fullvals=td.derivedtypes.init_fullvals(sysparams)\n\n\n\nMore information about the potential functions can be found in potential.qmd\n\nFortran\n\n  call generate_nbodypot(sysparams,sharedvals,fullvals)\n\nPython\n\n  td.potential.generate_nbodypot(sysparams,sharedvals,fullvals)\n\n\n\nFor certain example parameters, you can call\n\nFortran:\n\n  call initializefullsystem(sysparams,fullvals)\n\nPython\n\n  td.initial_states.initializedfullsystem(sysparams,fullvals)\nYou can also define your own initial fullvals%psi of length sysparams%ntot (sysparams.ntot). If the number of particles (sysparams%npart) is 1 then you must define fullvals%psi of length sysparams%ntot1=L^(number of dimensions)\n\n\n\nCreate a double precision or numpy.float64 vector of density of length sysparams%ntot1. Put the initial density of the system in this vector. If examining one of the examples from the paper\n\nFortran:\n\n  use density\n  real(8), allocatable :: dpe(:)\n  allocate(dpe(sysparams%ntot1))\n  call fullwf_density(sysparams,fullvals.psi,dpe)\n\nPython\n\n  dpe=np.zeros(sysparams.ntot1,dtype=np.float64)\n  td.density.fullwf_density(sysparams,fullvals%psi,dpe)\n\n\n\nThe program attemps to initialize the Kohn-Sham system using the full wavefunction density. The fullvals argument is optional and only used if one particle in KS system. If fullvals is present than KSvals%phi=fullvals%psi, otherwise KSvals%phi=dpe.\n\nFortran:\n\n  type(ksvalues) :: ksvals\n  call initializekssystem(sysparams,sharedvals,dpe,fullvals,ksvals)\n\nPython:\n\n  ksvals=td.initial_states.initializekssytem(sysparams,sharedvals,dpe,fullvals)\n\n\n\npropagate system\n\nFortran:\n\n  real(8), allocatable :: dpenew(:),dnx(:),ddnx(:),ddnxnew(:)\n  allocate(dpenew(sysparams%ntot1)) !density at time step sysparams%ct+sysparams%dt\n  allocate(dnx(sysparams%ntot1)) !time derivative of density at time sysparams%ct\n  allocate(ddnx(sysparams%ntot1)) !second time derivative of density at\n    !time sysparams%ct\n  allocate(ddnxnew(sysparams%ntot1)) !second time derivative of density at\n    !time sysparams%ct+sysparams%dt\n\nPython\n\n  dpenew=np.zeros(sysparams.ntot1,dtype=np.float64) #density after time step\n  dnx=np.zeros(sysparams.ntot1,dtype=np.float64) #current time derivative of density\n  ddnx=np.zeros(sysparams.ntot1,dtype=np.float64) #current second time\n    #derivative of density\n  ddnxnew=np.zeros(sysparams.ntot1,dtype=np.float64) #second time derivative\n    #of density after time step sysparams.dt"
  },
  {
    "objectID": "index.html#obtain-necessary-vectors",
    "href": "index.html#obtain-necessary-vectors",
    "title": "",
    "section": "Obtain necessary vectors",
    "text": "Obtain necessary vectors\nTo obtain one time step, you need to calculate the five vectors, dpe,dpenew,dnx,ddnx,and ddnxnew. For the examples in the paper, this can be done by\n\nFortran:\n\n  use propagate\n  complex(8), allocatable :: psinew(:)\n  call fullwf_density(sysparams,fullvals%psi,dpe)\n  call calcdnx(sysparams,sharedvals,sysparams%ntot1,fullvals%psi,fullvals%v,dnx)\n  call calcddnx(sysparams,sharedvals,sysparams%ntot1,fullvals%psi,fullvals%v,ddnx)\n  !Propagate full system and calculate new density and second derivative of density\n  allocate(psinew(sysparams%ntot))\n  call advancewf(sysparams,sharedvals,25,fullvals%v,fullvals%psi,psinew)\n  call fullwf_density(sysparams,psinew,dpenew)\n  call calcddnx(sysparams,sharedvals,sysparams%ntot1,psinew,fullvals%v,ddnxnew)\n\nPython\n\n  td.density.fullwf_density(sysparams,fullvals.psi,dpe)\n  td.density.calcdnx(sysparams,sharedvals,sysparams.ntot1,fullvals.psi,fullvals.v,dnx)\n  td.density.calcddnx(sysparams,sharedvals,sysparams.ntot1,fullvals.psi,fullvals.v,ddnx)\n  #propagate full system\n  td.propagate.advancewf(sysparams,sharedvals,25,fullvals.v,fullvals.psi,psinew)\n  #Calculate density and second derivative of density at time ct+dt using psinew\n  td.density.fullwf_density(sysparams,psinew,dpenew)\n  td.density.calcddnx(sysparams,sharedvals,sysparams.ntot1,psinew,fullvals.v,ddnxnew)\nIf one is obtaining these values by some other method, (like using a quantum computer. dpe,dnx,ddnx are the values at time sysparams%ct and dpenew,ddnxnew are the values at time sysparams%ct+sysparams%dt."
  },
  {
    "objectID": "index.html#attempt-to-propagate-system",
    "href": "index.html#attempt-to-propagate-system",
    "title": "",
    "section": "Attempt to propagate system",
    "text": "Attempt to propagate system\n\nFortran:\n\n  call advancekssystem(dpe,dpenew,dnx,ddnx,ddnxnew,sysparams,KSvals,sharedvals,info)\n\nPython\n\n  info = td.propagate.advancekssystem(dpe,dpenew,dnx,ddnx,ddnxnew,sysparams,KSvals,sharedvals)\nMore information about the generic time-propagation methods can be found in propagate.\n\nIf info=1\n\nThe orbitals advanced successfully.\nData has been output to\n\ntimes.dat has the current time sysparams%dt\nwave.dat has the current KS orbitals at times in times.dat\npots.dat has the potential values at times in times.dat\ndense.dat has the full density and KS density at times in times.dat\n\n\nwave.dat, pots.dat and dense.dat all separate different times by a double space in accordance with the gnuplot format index style. A sample output for each with titles for each column is given in\n\ntimes_sample.dat\nwave_sample.dat\npots_sample.dat\ndense_sample.dat\n\n\n\nIf info=0\n\nThe time step attempt has failed and (sysparams%dt) has been halved. A new ddnxnew and dpenew will need to be calculated at time sysparams%ct+sysparams%dt."
  },
  {
    "objectID": "index.html#obtaining-information-about-ks-system",
    "href": "index.html#obtaining-information-about-ks-system",
    "title": "",
    "section": "Obtaining information about KS system",
    "text": "Obtaining information about KS system\nApart from the information being outputed to a data file. All the information about the KS system is included in the ksvals derived type. More information about that derived type can be found at."
  },
  {
    "objectID": "fullvalues.html",
    "href": "fullvalues.html",
    "title": "",
    "section": "",
    "text": "This describes the fullvalues derived type. It is not necessary to use this derived type if the density of the full system is generated by a different method such as a quantum computer."
  },
  {
    "objectID": "fullvalues.html#mandatory-values-defined-by-user",
    "href": "fullvalues.html#mandatory-values-defined-by-user",
    "title": "",
    "section": "Mandatory values defined by user",
    "text": "Mandatory values defined by user\n\nv\n\nDescription\nThe full n-body potential if in first quantization or the 2-body potential if in 2nd quantization\n\n\nData type\nFortran: First quantization\nreal(8), dimension(sysparams%ntot)\nPython: First quantization\nnumpy.empty([sysparams%ntot],dtype=numpy.float64)\nFortran: Second quantization\nreal(8), dimension(sysparams%ntot2)\nPython: Second quantization\nnumpy.empty([sysparams%ntot2],dtype=numpy.float64)\n\n\n\npsi\n\nDescription\nThe vector that stores the full n-body wavefunction.\n\n\nData type\nFortran\ncomplex(8), dimension(sysparams%ntot)\nPython\nnumpy.empty([sysparams%ntot],dtype=numpy.complex128)"
  },
  {
    "objectID": "keomod.html",
    "href": "keomod.html",
    "title": "",
    "section": "",
    "text": "This is the module that contains the subroutine that generates the sinc discrete variable representation kinetic energy operator\n\n\n  !returns sysparams%T with sinc DVR KEO\n  subroutine buildkeo(sysparams)\n    type(systemparameters) ,intent(inout) :: sysparams"
  },
  {
    "objectID": "sharedvalues.html",
    "href": "sharedvalues.html",
    "title": "",
    "section": "",
    "text": "This describes each of the values located in the sharedvalues derived type\n\n\nThe arrays located in sharedvalues are allocated using the systemparameters derived type that has been properly initialized\nFortran\nuse derivedtypes\ntype(sharedvalues) :: sharedvals\ncall init_sharedvalues(sysparams,sharedvals)\nsharedvals=TDDFTinversion.derivedtypes.init_sharedvalues(sysparams)\n\n\n\n\n\n\n\nThe array for the initial external 1-body potential.\n\n\n\nreal(8), dimension(sysparams%ntot1)\nnumpy.empty([sysparams%ntot1],dtype=numpy.float64)\n\n\n\n\n\n\nThe time independant one-body potential\n\n\n\nreal(8), dimension(sysparams%ntot1)\nnumpy.empty([sysparams%ntot1],dtype=numpy.float64)\n\n\n\n\n\n\nThe 2-body interaction potential\n\n\n\nreal(8), dimension(sysparams%ntot2)\nnumpy.empty([sysparams%ntot2],dtype=numpy.float64)"
  },
  {
    "objectID": "systemparameters.html",
    "href": "systemparameters.html",
    "title": "",
    "section": "",
    "text": "This describes each of the values located in the systemparameters derived type.\n\n\nThis derived type (labelled sysparams here) is initialized using np1 (the number of grid points)\nFortran\ntype(systemparameters) :: sysparams\ninteger :: np1\ncall init_systemparameters(sysparams,np1)\nPython\nnp1=numpy.int32( )\nsysparams=TDDFTinversion.derivedtypes.init_systemparameters(np1)\nThe systemparameters derived type will now have the np1 value defined\n\n\n\n\nThe number of grid points in each dimension\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\nAfter initialization, user must add the following parameters to the derived type using commands such as\nFortran\nsysparams%value=...\nPython\nsysparams.value=...\n\n\n\n\nThe number of dimensions that each particle lives in. For first quantization, only 1,2, or 3 dimensions is allowed. For second quantization, only 1 dimension is allowed.\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\n\nThe number of particles in the total system\n\n\n\nFortran\ninteger\nPython\nnumpy.int32\n\n\n\n\n\n\nThe min position of the grid points that define the lattice with equal spacing of length n\n\n\n\nFortran\nreal(8) \nPython\nnumpy.float64\n\n\n\n\n\n\nThe min position of the grid points that define the lattice with equal spacing of length n\n\n\n\nFortran\nreal(8) \nPython\nnumpy.float64\n\n\n\n\n\n\nThe goal time step for the program. If an advance of the KS system fails, the actual time step will be less than this for the next attempt. However, the program will attempt to increase the time step back to this user defined timestep on future calls of the program.\n\n\n\nFortran\nreal(8) \nPython\nnumpy.float64\n\n\n\n\n\n\nThe one dimensional kinetic energy operator. For the sinc basis one can use Fortran\ncall buildkeo(sysparams)\nPython\nTDDFTinversion.keomod.buildkeo(sysparams)\nafter defining xmax and xmin\n\n\n\nFortran\nreal(8), dimension(np1,np1)\nnumpy.empty([np1,np1],dtype=numpy.float64)\n\n\n\n\n\nThese are values that may be initially defined by the user but should not be changed after the first call to propagate the KS system.\n\n\n\n\nThe current time in the propagation. Initialized to 0 by program.\n\n\n\nFortran\nreal(8) \nPython\nnumpy.float64\n\n\n\n\n\n\nThe current time-step size. Initially set to dth by program. It is often beneficial to start the propagation with a smaller time step so as to obtain the time derivative of the potential more accurately.\n\n\n\nFortran\nreal(8) \nPython\nnumpy.float64\n\n\n\n\n\n\nIf quantization = 1 then first quantization is used. If quantization =2 then second quantization is used. First quantization can be used for #nd=1,2,3 while second quantization can only be used for nd=1. Default is 1.\n\n\n\nFortran\ninteger\nPython\nnumpy.int32\n\n\n\n\n\n\n\n\n\nThe energy of KS system is rescaled to this value by shifting the calculated potential. If there is no energy imparted on the full system by a time-dependant potential than this value should be chosen to be some initial value and then not changed. Otherwise, a good choice may be to measure the full system’s energy at the beginning and end of each time step and use that value. Default is 0.\n\n\n\nFortran\nreal(8)\nPython\nnumpy.float64\n\n\n\n\n\n\nThe energy of KS system after time step dt is rescaled to this value by shifting the calculated potential. If there is no energy imparted on the full system by a time-dependant potential than this value should be chosen to be some initial value and then not changed. Otherwise, a good choice may be to measure the full system’s energy at the beginning and end of each time step and use that value. Default is 0. After call to fill_systemparameters, value is equal to energy.\n\n\n\nFortran\nreal(8)\nPython\nnumpy.float64\n\n\n\n\n\n\nThe parameter that determines which method is used to invert the potential. The recommended and initial setting is 1 which uses MINRES-QLP. If you are in 1D, setting pinv0minresqlp1 will utilize the Morse-Penrose pseudo inverse.\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\n\nThe parameter defines the symmetry for a two particle first quantized system with singlet symmetry. 0 means singlet symmetry is not enforced. 1 means singlet symmetry is enforced. Default is 0.\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\n\nThe parameter defines the symmetry for a two particle first quantized system with triplet symmetry. 0 means triplet symmetry is not enforced. 1 means triplet symmetry is enforced. Default is 0.\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\n\nThe maximum time derivative of the inverted potential at a given point. The initial value is 1000.\n\n\n\nFortran\nreal(8)\nnumpy.float64\n\n\n\n\n\n\nThe flag that determines whether the output of data will be in a newfile or appended to the previous files. If set to 1, the old files will be overwritten. Otherwise, the new data will be appended to the old files.The description of the output files is in the main index newfile is initialized to 1 and then after every time data is written reverts to 0.\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\n\nThe flag that determines whether the current Kohn-Sham values will be outputted to data files. If set to 1, the data will be written to file. Otherwise, no data will be written.\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\nThe following are systemparameter values that are accessible to the user but should not be altered. They are determined by the program by Fortran\ncall fill_systemparameters(sysparams)\nPython\nTDDFTinversion.derivedtypes.fill_systemparameters(sysparams)\n\n\n\n\nThe number of grid points that defines each particle. np1nd\n\n\n\nFortran\ninteger \nPython\nnumpy.int32\n\n\n\n\n\n\nThe number of grid points that defines two particles. np12 nd\n\n\n\nFortran\ninteger\nPython\nnumpy.int32\n\n\n\n\n\n\nThe number of grid points that defines the full system wavefunction.\nIf in first quantization: ntot=ntot1npart\nIf in second quantization: ntot=ntot1 choose npart\n\n\n\nFortran\ninteger\nPython\nnumpy.int32\n\n\n\n\n\n\nThe grid spacing. (xmax-xmin)/(np1-1)\n\n\n\nFortran\nreal(8)\nPython\nnumpy.float64\n\n\n\n\n\n\nThe equally spaced grid points for one dimension defined by xmin,xmax and np1.\n\n\n\nFortran\nreal(8), dimension(sysparams%np1)\nPython\nnumpy.empty([sysparams%np1,1],dtype=numpy.float64)"
  },
  {
    "objectID": "ksvalues.html",
    "href": "ksvalues.html",
    "title": "",
    "section": "",
    "text": "The derived type that stores all vectors related to the KS system\n\n\nIf you would like to initialize the orbitals using your own method, the arrays can be allocated using\nFortran\ntype(ksvalues) :: ksvals\ncall init_ksvalues(sysparams,ksvals)\nPython\nksvals=TDDFTinversion.derivedtypes.init_ksvalues(sysparams)\nIf you would like to allow the program to initialize the KS orbitals Fortran\ntype(ksvalues) :: ksvals\ncall initializekssystem(sysparams,sharevals,exactdensity,fullvals,ksvals)\nPython\nksvals=TDDFTinversion.initial_states.initializeksystem(sysparams,sharedvals,exactdensity,fullvals)\nwhere exactdensity is a real(8) or numpy.float64 vector of length sysparams%ntot1 or sysparams.ntot1 which has the exact density and fullvals is the fullvalues derived type.\n\n\n\n\n\n\n\nThe ntot1 by npart array that stores the orbitals of the KS system. Before beginning the propagation of the KS system. These orbitals should be defined by the user such that the density and derivative of the density match the target system. If orbitals are defined such that the density matches but the derivative of the density does not. The program will try to assign the phases to correct this but this will not work well unless the initial derivative of the density is close to the target derivative of the density.\n\n\n\nFortran\ncomplex(8), dimension(ntot1,npart)\nPython\nnumpy.empty([ntot1,npart],dtype=numpy.complex128)\n\n\n\n\n\n\n\n\n\nThe density of the KS system at time systemparameters%ct\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1,npart],dtype=numpy.float64)\n\n\n\n\n\n\nThe full 1-body KS potential at time systemparameters%ct\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1,npart],dtype=numpy.float64)\n\n\n\n\n\n\nThe full 1-body KS potential with sharedvalues%v1 subtracted off for time from the previous successful timestep\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1],dtype=numpy.float64)\n\n\n\n\n\n\nThe full 1-body KS potential with sharedvalues%v1 subtracted off for time from the previous to previous successful timestep\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1],dtype=numpy.float64)\n\n\n\n\n\n\nThe hartree potential calculated using dp and sharedvalues%vinteract at the current time\n\n\n\n\n\n\nThe full 1-body KS potential with sharedvalues%v1 subtracted off for time from the previous successful timestep\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1],dtype=numpy.float64)\n\n\n\n\n\n\nThe current estimate of the derivative of the vks potential with respect to time\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1],dtype=numpy.float64)\n\n\n\n\n\n\nThe previous to current time derivative of the vks potential.\n\n\n\nFortran\nreal(8), dimension(ntot1)\nPython\nnumpy.empty([ntot1],dtype=numpy.float64)"
  }
]